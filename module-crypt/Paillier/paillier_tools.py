"""
paillier_tools.py
Additional routines/tools that are too long to really type during the workshop.

This software is part of the DeapSECURE training program.

Copyright (c) 2018-2021 The DeapSECURE team
Copyright (c) 2018-2021 Old Dominion University


LICENSE

This library can be distributed, used, modified according to the license terms
set forth by the DeapSECURE team.

For the DeapSECURE project, please visit our website:
https://deapsecure.gitlab.io/
"""

# import additional stuff needed later on:
import json
import sys

# import Paillier library
import phe
from phe import paillier

__version__ = 0.01

#pubkey, privkey = paillier.generate_paillier_keypair(n_length=2048)

# The JWK format was proposed in python-paillier documentation:
#
# https://python-paillier.readthedocs.io/en/develop/serialisation.html#jwk-serialisation
#
# We try to create a close-to-standard data format on-disk or in-transit.
# JWK stands for JSON Web Key. See https://tools.ietf.org/html/rfc7517 .
# JWK is basically a JSON format with predefined structure.
# The metadata helps identify that the data as being a Paillier key
# (private or public).

def keypair_dump_jwk(pub, priv, date=None, json_flags={}):
    """Serializer for public-private keypair, to JWK format.

    Input:
    - pub: a PaillierPublicKey object
    - priv: the corresponding PaillierPrivateKey object
    - date: optional, the date string of key creation

    Output: a two-tuple containing the serialized public and private keys
    in the JWK format.

    Example usage:

    >>> pub_jwk, priv_jwk = keypair_dump_jwk(pubkey, privkey, '2020-12-17')
    >>> write_file('my-key.pub', pub_jwk)
    >>> write_file('my-key.priv', priv_jwk)
    """
    # https://python-paillier.readthedocs.io/en/develop/serialisation.html#jwk-serialisation
    from datetime import datetime
    if date is None:
        date = datetime.now().strftime('%Y-%m-%dT%H:%M:%S')

    rec_pub = {
        'kty': 'DAJ',
        'alg': 'PAI-GN1',
        'key_ops': ['encrypt'],
        'n': phe.util.int_to_base64(pub.n),
        'kid': 'Paillier public key generated by phe on {}'.format(date)
    }

    rec_priv = {
        'kty': 'DAJ',
        'key_ops': ['decrypt'],
        'p': phe.util.int_to_base64(priv.p),
        'q': phe.util.int_to_base64(priv.q),
        'kid': 'Paillier private key generated by phe on {}'.format(date)
    }

    pub_jwk = json.dumps(rec_pub, **json_flags)
    priv_jwk = json.dumps(rec_priv, **json_flags)
    return pub_jwk, priv_jwk


def keypair_load_jwk(pub_jwk, priv_jwk):
    """Deserializer for public-private keypair, from JWK format."""
    rec_pub = json.loads(pub_jwk)
    rec_priv = json.loads(priv_jwk)
    # Do some basic checks
    assert rec_pub['kty'] == "DAJ", "Invalid public key type"
    assert rec_pub['alg'] == "PAI-GN1", "Invalid public key algorithm"
    assert rec_priv['kty'] == "DAJ", "Invalid private key type"
    pub_n = phe.util.base64_to_int(rec_pub['n'])
    pub = paillier.PaillierPublicKey(pub_n)
    priv_p = phe.util.base64_to_int(rec_priv['p'])
    priv_q = phe.util.base64_to_int(rec_priv['q'])
    priv = paillier.PaillierPrivateKey(pub, priv_p, priv_q)
    return pub, priv


def pubkey_load_jwk(pub_jwk):
    """Deserializer for public key only, from JWK format."""
    rec_pub = json.loads(pub_jwk)
    # Do some basic checks
    assert rec_pub['kty'] == "DAJ", "Invalid public key type"
    assert rec_pub['alg'] == "PAI-GN1", "Invalid public key algorithm"
    pub_n = phe.util.base64_to_int(rec_pub['n'])
    pub = paillier.PaillierPublicKey(pub_n)
    return pub


def privkey_load_jwk(priv_jwk):
    """Deserializer for private key only, from JWK format.
    This routine will also reconstitute the public key."""
    # CAUTION: This routine somewhat sidesteps the public API by assuming
    # the form of public key (n=p*q)--which is valid as of the time of writing.
    rec_priv = json.loads(priv_jwk)
    # Do some basic checks
    assert rec_priv['kty'] == "DAJ", "Invalid private key type"
    assert 'decrypt' in rec_priv['key_ops'], "Invalid private key_ops"
    priv_p = phe.util.base64_to_int(rec_priv['p'])
    priv_q = phe.util.base64_to_int(rec_priv['q'])
    pub_n = priv_p * priv_q
    pub = paillier.PaillierPublicKey(pub_n)
    priv = paillier.PaillierPrivateKey(pub, priv_p, priv_q)
    return pub, priv


# The encoding of encrypted numbers are simple JSON for now.
# Later we can use the JSON Web Encryption, https://tools.ietf.org/html/rfc7516 .

def envec_dump_json(pubkey, enc_vals, indent=None):
    """Serializes a vector of encrypted numbers into a simple JSON format.

    Input:
    * pubkey is a PaillierPublicKey object.
    * enc_vals is a list of EncryptedNumber objects.
    * indent can be none (for no indentation), or an integer>0 to pretty-print
      the JSON output with that number of whitespaces per indentation
    """
    from phe.util import int_to_base64
    R = {}
    R['public_key'] = {
        # 'g': pubkey.g,  # skipping g; it is equal to n+1
        'n': int_to_base64(pubkey.n),
    }
    R['values'] = [
        (int_to_base64(x.ciphertext()), x.exponent) for x in enc_vals
    ]
    return json.dumps(R, indent=indent)


def envec_load_json(R_json):
    """Deserializes a vector of encrypted numbers.
    The `R_json` argument is a JSON format produced by envec_dump_json.
    """
    from phe.util import base64_to_int
    R = json.loads(R_json)
    R_pubkey = R['public_key']
    R_values = R['values']

    # deserialized values:
    pubkey_d = paillier.PaillierPublicKey(n=base64_to_int(R_pubkey['n']))
    values_d = [
        paillier.EncryptedNumber(pubkey_d, ciphertext=base64_to_int(v[0]), exponent=int(v[1]))
        for v in R_values
    ]
    return pubkey_d, values_d


def validate_array2d(arr, shape):
    """Performs validation of 2D array based on the declared shape.
    Throws an exception when an error is detected; otherwise,
    the function will return successfully."""
    t_shape = tuple(shape)

    # Performs validations
    # We do some basic verifications here; we could have done more but
    # it is too much!
    assert len(t_shape) == 2
    ysize, xsize = t_shape
    assert len(arr) == ysize
    # Check the row-vector dimension, row by row:
    for (i,row_img) in enumerate(arr):
        if len(row_img) != xsize:
            print("validate_array2d: Bad number of columns in row {}: {} instead of {}" \
                  .format(i, len(row_img), xsize),
                  file=sys.stderr)
            assert len(row_img) == xsize   # trigger the error


def enimg_dump_json(pubkey, enc_img, shape, shape_orig,
                    comment=None, filename=None, json_flags={}):
    """Dumps an encrypted image (2-D array) to a JSON string or to a JSON file.
    Adds some basic metadata to help identify the file later on.

    Args:

      - pub_key (PaillierPublicKey): The public key
      - enc_img (a list of lists): the encrypted image's ciphertexts,
        where each number is already encoded individually with base64
      - shape (2-int tuple or list): the shape of the encrypted image
      - shape_orig (tuple or list of ints): the shape of the ORIGINAL
        image before any preprocessing
      - comment (str, optional): A comment string
      - indent (int or None): JSON indentation level
      - filename (str or None): Name of the output file, or None

    Returns: a JSON string, or None.
    If `filename` is None, this function will return the JSON data as a string;
    otherwise, it will create or overwrite the file and dump the data directly
    to the file to save memory.

    The enc_img should be a nested list.
    The outer dimension is the row numbers (ysize), and the inner dimension
    is the column number (xsize).
    """
    validate_array2d(enc_img, shape)
    t_shape = tuple(shape)
    ysize, xsize = t_shape

    result = {}
    # Store a lot of metadata so we can comprehend the file later on
    result['file_type'] = 'EncryptedImage'
    result['fmt_version'] = '0.0'
    result['kty'] = 'DAJ'
    result['alg'] = 'PAI-GN1'
    # Note: Don't include filename because that may also divulge something sensitive
    if comment is not None:
        result['comment'] = comment
    result['shape_orig'] = list(shape_orig)
    result['shape'] = t_shape
    result['public_key'] = {'n': phe.util.int_to_base64(pubkey.n)}
    result['values'] = enc_img

    if filename is not None:
        with open(filename, 'w') as F:
            json.dump(result, F, **json_flags)
    else:
        return json.dumps(result, **json_flags)


def enimg_load_json(src, from_file='auto'):
    """Loads an encrypted 2-D array (grayscale image) from a JSON stream
    or from a disk file.

    Returns: a 3-tuple of (public_key, encrypted_pixels, shape)

    * public_key (PaillierPublicKey): the public key
    * encrypted_pixels: a nested list containing raw encrypted values
      (whichever datatype was the encrypted form dumped to the JSON stream)
    * shape: a 2-tuple of the array shape
    """
    from phe.util import base64_to_int

    if from_file == 'auto':
        head = src[:256].strip()
        tail = src[-256:].rstrip()
        if (head[0] in ('{', '[')) and (tail[-1] in ('}', ']')):
            from_file = False
        else:
            from_file = True

    if from_file:
        with open(src, 'r') as F:
            result = json.load(F)
    else:
        result = json.loads(src)

    # Performs a series of validation
    assert isinstance(result, dict)
    assert result['file_type'] == 'EncryptedImage'
    assert result['kty'] == 'DAJ'
    assert result['alg'] == 'PAI-GN1'
    assert 'shape' in result
    assert 'values' in result
    assert 'public_key' in result
    shape = tuple(result['shape'])
    enc_img = result['values']
    validate_array2d(enc_img, shape)
    R_pubkey = result['public_key']

    pub_n = base64_to_int(R_pubkey['n'])

    # deserialized values:
    pubkey_d = paillier.PaillierPublicKey(n=pub_n)

    # These have been extracted:
    del result['values']
    del result['public_key']
    return pubkey_d, enc_img, shape


def convert_to_grayscale(image_orig):
    if len(image_orig.shape) == 2:
        # Assume grayscale image
        print("Note: image is in grayscale already.")
        gray = image_orig
    else:
        # Assertion forcing RGB image format
        assert len(image_orig.shape) == 3
        assert image_orig.shape[2] >= 3
        print("Note: image is converted to grayscale.")
        # Converting RGB to grayscale
        # Link to formula : https://en.wikipedia.org/wiki/Grayscale#Luma_coding_in_video_systems
        # More Discussion : https://e2eml.school/convert_rgb_to_grayscale.html
        gray = np.dot(image_orig[...,:3], [0.299, 0.587, 0.114])
    return gray


def read_file(filename):
    """Reads an entire text file to a string."""
    with open(filename, "r") as F:
        R = F.read()
    return R


def write_file(filename, S):
    """Writes an entire text (S) to a text file."""
    with open(filename, "w") as F:
        F.write(S)
